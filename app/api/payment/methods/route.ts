import { NextRequest, NextResponse } from "next/server";
import { createClient, copyResponseCookies } from "@/lib/supabase/client";

export async function GET(request: NextRequest) {
  try {
    const { supabase, response } = createClient(request);
    const url = new URL(request.url);
    const estId = Number(url.searchParams.get('est_id'));

    if (!estId || estId <= 0) {
      return NextResponse.json({
        error: "ID de estacionamiento inv√°lido",
        methods: []
      }, { status: 400 });
    }

    console.log(`üîç Obteniendo m√©todos para estId: ${estId}`);

    // Obtener m√©todos disponibles
    const { data: allMethods, error: methodsError } = await supabase
      .from("metodos_pagos")
      .select("mepa_metodo, mepa_descripcion");

    if (methodsError) {
      console.error("Error obteniendo m√©todos:", methodsError);
      return NextResponse.json({ error: methodsError.message }, { status: 500 });
    }

    // Obtener m√©todos aceptados por este estacionamiento
    const { data: acceptedMethods, error: acceptedError } = await supabase
      .from("est_acepta_metodospago")
      .select("mepa_metodo")
      .eq("est_id", estId);

    if (acceptedError) {
      console.error("Error obteniendo m√©todos aceptados:", acceptedError);
      return NextResponse.json({ error: acceptedError.message }, { status: 500 });
    }

    // Crear Set con m√©todos aceptados
    const acceptedSet = new Set(acceptedMethods?.map(am => am.mepa_metodo) || []);

    console.log(`üìä Estacionamiento ${estId}: ${acceptedMethods?.length || 0} m√©todos configurados`);
    console.log(`üìã M√©todos configurados: ${Array.from(acceptedSet).join(', ') || 'NINGUNO'}`);

    // Crear lista de m√©todos
    const methods = [
      ...(allMethods || []).map(method => ({
        method: method.mepa_metodo,
        description: method.mepa_descripcion,
        enabled: acceptedSet.has(method.mepa_metodo)
      })),
      {
        method: 'QR',
        description: 'C√≥digo QR de MercadoPago',
        enabled: acceptedSet.has('MercadoPago')
      }
    ];

    console.log(`‚úÖ M√©todos a devolver:`, methods.map(m => `${m.method}: ${m.enabled}`).join(', '));

    const jsonResponse = NextResponse.json({ methods });
    return copyResponseCookies(response, jsonResponse);
  } catch (error) {
    console.error("Error en GET /api/payment/methods:", error);
    return NextResponse.json(
      { error: "Error interno del servidor" },
      { status: 500 }
    );
  }
}

// Endpoint para auto-configurar m√©todos de pago por defecto
export async function PUT(request: NextRequest) {
  try {
    const { supabase, response } = createClient(request);
    const url = new URL(request.url);
    const estId = Number(url.searchParams.get('est_id')) || 1;

    console.log(`üîß Auto-configurando m√©todos de pago para estacionamiento ${estId}`);

    // Verificar que no haya m√©todos ya configurados
    const { data: existingMethods, error: checkError } = await supabase
      .from("est_acepta_metodospago")
      .select("mepa_metodo")
      .eq("est_id", estId);

    if (checkError) {
      console.error("‚ùå Error verificando m√©todos existentes:", checkError);
      return NextResponse.json({ error: "Error verificando configuraci√≥n actual" }, { status: 500 });
    }

    // Si ya hay m√©todos configurados, no hacer nada
    if (existingMethods && existingMethods.length > 0) {
      console.log(`‚ÑπÔ∏è El estacionamiento ${estId} ya tiene ${existingMethods.length} m√©todos configurados`);
      const jsonResponse = NextResponse.json({
        message: "Los m√©todos de pago ya est√°n configurados",
        configured_methods: existingMethods.length
      });
      return copyResponseCookies(response, jsonResponse);
    }

    // Configurar m√©todos por defecto
    const defaultMethods = [
      { est_id: estId, mepa_metodo: 'Efectivo' },
      { est_id: estId, mepa_metodo: 'Transferencia' },
      { est_id: estId, mepa_metodo: 'MercadoPago' }
    ];

    const { error: insertError } = await supabase
      .from("est_acepta_metodospago")
      .insert(defaultMethods);

    if (insertError) {
      console.error("‚ùå Error configurando m√©todos por defecto:", insertError);
      return NextResponse.json({
        error: "Error configurando m√©todos de pago",
        details: insertError.message
      }, { status: 500 });
    }

    console.log(`‚úÖ Auto-configurados ${defaultMethods.length} m√©todos de pago para estacionamiento ${estId}`);

    const jsonResponse = NextResponse.json({
      success: true,
      message: `Configurados ${defaultMethods.length} m√©todos de pago por defecto`,
      configured_methods: defaultMethods.map(m => m.mepa_metodo)
    });
    return copyResponseCookies(response, jsonResponse);

  } catch (error) {
    console.error("‚ùå Error en PUT /api/payment/methods:", error);
    return NextResponse.json(
      { error: "Error interno del servidor" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const { method, enabled } = await request.json();
    const { supabase, response } = createClient(request);
    const url = new URL(request.url);
    const estId = Number(url.searchParams.get('est_id')) || 1;

    if (!method) {
      return NextResponse.json({ error: "M√©todo de pago requerido" }, { status: 400 });
    }

    // Manejar QR como m√©todo especial (es equivalente a MercadoPago)
    if (method === 'QR') {
      if (enabled) {
        // Para QR, habilitamos MercadoPago en la base de datos
        const { error: insertError } = await supabase
          .from("est_acepta_metodospago")
          .upsert({
            est_id: estId,
            mepa_metodo: 'MercadoPago'
          }, {
            onConflict: 'est_id,mepa_metodo'
          });

        if (insertError) {
          console.error("Error habilitando MercadoPago para QR:", insertError);
          return NextResponse.json({ error: insertError.message }, { status: 500 });
        }
      } else {
        // Para deshabilitar QR, deshabilitamos MercadoPago
        const { error: deleteError } = await supabase
          .from("est_acepta_metodospago")
          .delete()
          .eq("est_id", estId)
          .eq("mepa_metodo", 'MercadoPago');

        if (deleteError) {
          console.error("Error deshabilitando MercadoPago para QR:", deleteError);
          return NextResponse.json({ error: deleteError.message }, { status: 500 });
        }
      }
    } else {
      // M√©todo normal (Efectivo, Transferencia, MercadoPago)
      if (enabled) {
        // Habilitar m√©todo: insertar en est_acepta_metodospago
        const { error: insertError } = await supabase
          .from("est_acepta_metodospago")
          .upsert({
            est_id: estId,
            mepa_metodo: method
          }, {
            onConflict: 'est_id,mepa_metodo'
          });

        if (insertError) {
          console.error("Error habilitando m√©todo:", insertError);
          return NextResponse.json({ error: insertError.message }, { status: 500 });
        }
      } else {
        // Deshabilitar m√©todo: eliminar de est_acepta_metodospago
        const { error: deleteError } = await supabase
          .from("est_acepta_metodospago")
          .delete()
          .eq("est_id", estId)
          .eq("mepa_metodo", method);

        if (deleteError) {
          console.error("Error deshabilitando m√©todo:", deleteError);
          return NextResponse.json({ error: deleteError.message }, { status: 500 });
        }
      }
    }

    const jsonResponse = NextResponse.json({
      success: true,
      message: `M√©todo ${method} ${enabled ? 'habilitado' : 'deshabilitado'} correctamente`
    });
    return copyResponseCookies(response, jsonResponse);
  } catch (error) {
    console.error("Error en POST /api/payment/methods:", error);
    return NextResponse.json(
      { error: "Error interno del servidor" },
      { status: 500 }
    );
  }
}
